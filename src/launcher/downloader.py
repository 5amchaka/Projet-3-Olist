"""Téléchargement des fichiers CSV depuis Kaggle."""

import hashlib
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import TYPE_CHECKING

from src.config import CSV_FILES, RAW_DIR

if TYPE_CHECKING:
    from src.launcher.ui import UIManager


class DownloadError(Exception):
    """Erreur lors du téléchargement."""


class KaggleDownloader:
    """Gestionnaire de téléchargement des datasets Kaggle."""

    DATASET_SLUG = "olistbr/brazilian-ecommerce"

    def __init__(self, ui: "UIManager"):
        self.ui = ui

    def download_all(self) -> None:
        """Télécharger le dataset complet depuis Kaggle."""
        # Créer le répertoire RAW_DIR s'il n'existe pas
        RAW_DIR.mkdir(parents=True, exist_ok=True)

        self.ui.info(f"Downloading {self.DATASET_SLUG}...")

        # Trouver la commande kaggle dans le venv ou dans le PATH
        kaggle_cmd = shutil.which("kaggle")
        if not kaggle_cmd:
            # Si pas dans PATH, essayer dans le venv
            venv_bin = Path(sys.executable).parent
            kaggle_cmd = str(venv_bin / "kaggle")
            if not Path(kaggle_cmd).exists():
                raise DownloadError(
                    "kaggle CLI not found. Install with: uv pip install kaggle"
                )

        try:
            # Utiliser la CLI Kaggle pour télécharger
            result = subprocess.run(
                [
                    kaggle_cmd,
                    "datasets",
                    "download",
                    "-d",
                    self.DATASET_SLUG,
                    "-p",
                    str(RAW_DIR),
                    "--unzip",
                    "--force",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

            if result.stdout:
                self.ui.info(result.stdout.strip())

        except subprocess.CalledProcessError as e:
            error_msg = e.stderr if e.stderr else str(e)
            raise DownloadError(f"Kaggle download failed: {error_msg}") from e

        # Vérifier que tous les fichiers sont présents
        self._verify_downloaded_files()

        # Générer le manifest
        self._generate_manifest()

        self.ui.success(f"Downloaded {len(CSV_FILES)} CSV files")

    def _verify_downloaded_files(self) -> None:
        """Vérifier que tous les fichiers CSV attendus sont présents."""
        missing_files = []
        for name, filename in CSV_FILES.items():
            csv_path = RAW_DIR / filename
            if not csv_path.exists():
                missing_files.append(filename)

        if missing_files:
            raise DownloadError(
                f"Missing CSV files after download: {', '.join(missing_files)}"
            )

    def _generate_manifest(self) -> None:
        """Générer un fichier manifest.txt avec les métadonnées des fichiers."""
        manifest_path = RAW_DIR / "manifest.txt"

        lines = ["# Olist Dataset Manifest", "# Generated by launcher", ""]

        for name, filename in sorted(CSV_FILES.items()):
            csv_path = RAW_DIR / filename

            if not csv_path.exists():
                continue

            # Compter les lignes
            line_count = self._count_lines(csv_path)

            # Calculer le MD5
            md5_hash = self._compute_md5(csv_path)

            # Taille du fichier
            size_mb = csv_path.stat().st_size / (1024 * 1024)

            lines.append(
                f"{filename:<50} {line_count:>10} lines  {size_mb:>8.2f} MB  {md5_hash}"
            )

        manifest_path.write_text("\n".join(lines) + "\n")
        self.ui.info(f"Manifest generated: {manifest_path}")

    def _count_lines(self, file_path: Path) -> int:
        """Compter le nombre de lignes dans un fichier."""
        with file_path.open("rb") as f:
            return sum(1 for _ in f)

    def _compute_md5(self, file_path: Path) -> str:
        """Calculer le hash MD5 d'un fichier."""
        md5 = hashlib.md5()
        with file_path.open("rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                md5.update(chunk)
        return md5.hexdigest()

    def should_download(self, force: bool = False) -> bool:
        """Déterminer si le téléchargement est nécessaire.

        Args:
            force: Force le téléchargement même si les fichiers existent

        Returns:
            True si le téléchargement est nécessaire
        """
        if force:
            return True

        if not RAW_DIR.exists():
            return True

        # Vérifier si tous les fichiers sont présents
        for filename in CSV_FILES.values():
            if not (RAW_DIR / filename).exists():
                return True

        return False
